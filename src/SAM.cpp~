#include "SAM.h"

void pushTableStFr(TableStFr *stfr, string s){
	vector<string>::iterator it = find((stfr->stringV).begin(), (stfr->stringV).end(), s);
	int pos;
	if(it != (stfr->stringV).end()){
		pos = it - (stfr->stringV).begin();
		(stfr->frecV)[pos] ++;
	}
	else{
		(stfr->stringV).push_back(s);
		(stfr->frecV).push_back(1);
	}
}

void pushRPP(vector<RPP>& rpp, string RN, int PO, cds_word Pe){
	RPP aux = {RN, PO, Pe};
	rpp.push_back(aux);
}

void pushPSR(PSR *psr, string RN, int PO, cds_word Pe, string SE){
	pushRPP(psr->rpp, RN, PO, Pe);
	(psr->SEQ).push_back(SE);
}

void pushREFI(REFI *refi, int FL, int MA){
	(refi->FLAG).push_back(FL);
	(refi->MAPQ).push_back(MA);
}

void clearPSR(PSR *psr){
	FreeAll(psr->SEQ);
	FreeAll(psr->rpp);
}


void clearREFI(REFI *refi){
	(refi->FLAG).clear();
	(refi->MAPQ).clear();
}

void Tokenize(const string& str, vector<string>& tokens, const string& delimiters){
	string::size_type last_pos = 0;
	string::size_type pos = str.find_first_of(delimiters);
	while(pos!=string::npos) {
		tokens.push_back(str.substr(last_pos,pos-last_pos));
		last_pos = pos+1;
		if(last_pos >= str.length())
			break;
		pos = str.find_first_of(delimiters,pos+1);
	}
	if(last_pos<str.length())
		tokens.push_back(str.substr(last_pos));
}

bool compareRPP(RPP first, RPP second){
	cds_word i=0;
	string f = first.RNAME;
	string s = second.RNAME;
	/*should force the RNAME == "*" be at the beggining*/
	while( (i < f.length()) && (i < s.length()) ){
		if (f[i] < s[i])
			return true;
		else if(f[i] > s[i])
			return false;
		++i;
	}
	if(f.length() < s.length())
		return true;
	else if(f.length() > s.length())
		return false;
	else{
		if(first.POS < second.POS)
			return true;
		else
			return false;
	}
}

